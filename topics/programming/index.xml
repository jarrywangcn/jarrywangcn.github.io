<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>99 problems</title>
    <link>https://jarrywangcn.github.io/topics/programming/index.xml</link>
    <description>Recent content on 99 problems</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <atom:link href="https://jarrywangcn.github.io/topics/programming/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>连接tws接口的一个小bug</title>
      <link>https://jarrywangcn.github.io/post/data_structure/</link>
      <pubDate>Sat, 10 Jun 2017 00:09:08 +0800</pubDate>
      
      <guid>https://jarrywangcn.github.io/post/data_structure/</guid>
      <description>&lt;p&gt;和tws没什么关系，是数据结构的基础没打好留下的坑&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;目前用的交易框架是backtrader，策略模块是component-based的思路设计的，简单来说，假设有一个策略是黄金反转系统，主文件是gold_reverse.py，开仓规则写在class entry里，平仓规则写在class exit里，不同策略需要的component不同，有些需要单边市判断，就要多一个class one-sided。&lt;/p&gt;

&lt;p&gt;但也有一些component是所有策略都需要的，比如说当前的持仓情况，就有/components/common.py 来记录这些函数，目前还拥有一些模块，money（开仓头寸的计算），booking（记录所有拥有的交易单和止损单），addunit（加仓模块），execute（执行买卖单，止损单，平仓的method）。&lt;/p&gt;

&lt;p&gt;最近开始连经纪商实盘测试，backtest一点问题也没有，live trading就各种bug。前两三天遇到的一个bug是：下交易单时带着的止损单不能执行，是下个next（如果周期是M10，就是十分钟后）backtrader看市场当年价格是否满足止损条件决定平不平仓（那要止损单何用！）一开始以为是execute的问题，但测试时把booking去掉就行了。&lt;/p&gt;

&lt;p&gt;讲一下当时写execute和booking的思路。一开始小伙伴A（程序员）提供的sample里self.order是一个单独的object（因为只考虑了不加仓的情况）。后来小伙伴B提出应该拥有一个booking模块记录所有的交易单和止损单，我们设想的是表格的形式，比如说column_name为单子的方向，大小，状态，市场，等等等。所以一开始想的数据格式就是pandas的dataframe。&lt;/p&gt;

&lt;p&gt;这时候不得不提backtrader每个交易单执行后返回的是个拥有很多attributes的object。attributes有ref（特定的编码）、size、stage、alive……&lt;/p&gt;

&lt;p&gt;而dataframe是不能存储这样的obejct，而且如果是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;self.order = self.strategy.buy( data= self.data, size = size) #执行买单
self.a = self.order
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;self.a保存的object和self.order保存的object不是同一个（这个部分我也不明白是怎么回事 但测试是这样）
所以到时候self.strategy.cancel(self.a)并不能cancel到你想要的那个order&lt;/p&gt;

&lt;p&gt;我那时候的思路还是在self.order, self.stoplossorder是单个的object，于是我写出了非常丑陋的代码……&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;##### initial orderbook #####

if self.execute.order:
    orderrecord = {
        &#39;Market&#39;:self.market,
        &#39;OrderID&#39;:self.execute.order.ref,
        &#39;Price&#39;:self.data.close,
        &#39;Size&#39;:self.execute.order.size,
        &#39;Position&#39;:len(self),
        &#39;Status&#39;:self.execute.order.status,
        &#39;Alive&#39;: self.execute.order.alive,
        }

##### initial stoploss orderbook #####

if self.execute.stoplossorder and self.execute.order:
    stoporderrecord = {
        &#39;Market&#39;:self.market,
        &#39;StopOrderID&#39;:self.execute.stoplossorder.ref,
        &#39;StopPrice&#39;:self.execute.stoplossorder.price,
        &#39;Size&#39;:self.execute.stoplossorder.size,
        &#39;OrderID&#39;:self.execute.order.ref,#####
        &#39;Status&#39;:self.execute.stoplossorder.status,
        &#39;Alive&#39;: self.execute.stoplossorder.alive,
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在execute的关闭止损单就更丑了&amp;hellip;放在了文章最后&lt;/p&gt;

&lt;p&gt;其实写完我发现我写的booking几乎没啥用，唯一的用处好像是知道当前场上加了多少次仓，然后获取最后一次加仓的止损单的状态，如果止损单被平了就退场，但当时能用就这么用着吧……&lt;/p&gt;

&lt;p&gt;但live trading的时候就不能用了…… 我至今不知道具体的原因。&lt;/p&gt;

&lt;p&gt;因为自己解决不了bug，求助小伙伴A时，被喷了。大致就是“这代码写得什么鬼，重写！”然后被教育重读/打了一遍《think python》，被建议用List。&lt;/p&gt;

&lt;p&gt;完了，我就把booking和execute全删了，把功能写在了common里，把self.order和self.stoplossorder调成为List Object。&lt;/p&gt;

&lt;p&gt;代码如下（以止损和关闭仓位的函数作为对比：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def stop_loss(self, side, size, stoplossprice):
    logger.warning(&#39;[{}] stop loss, side = {}, size = {}, price = {}&#39;.format(len(self), side, size, stoplossprice))

    if side == -1:
        self.stoplossorder.append(self.strategy.sell(
        data = self.data,
        size = size,
        price = stoplossprice,
        exectype = bt.Order.Stop,
        ))
    elif side == 1:
        self.stoplossorder.append(self.strategy.buy(
        data = self.data,
        size = size,
        price = stoplossprice,
        exectype = bt.Order.Stop,
        ))

def close_pos(self):
    logger.warning(&#39;[{}] close positions&#39;.format(len(self)))

    if self.common.side != 0:
        order = self.order_target_size(
        target = 0,
        )

    for i in range(len(self.stoplossorder)):
        if self.stoplossorder[i].alive():
            self.strategy.cancel(self.stoplossorder[i])

    self.stoplossorder = []
    self.order = []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嗯，之前写的什么鬼……&lt;/p&gt;

&lt;p&gt;总之：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;很多想法一开始是好的，比如说booking dataframe的形式，但实现起来往往没什么用。&lt;/li&gt;
&lt;li&gt;对基础数据结构的理解很弱，经常是没有思考，写到哪算哪，能work就好了（虽然这样也行）&lt;/li&gt;
&lt;li&gt;如果不work了就进行重构，也算是进步。
（总能找到很多方法安慰自己&lt;/li&gt;
&lt;li&gt;最后，这个bug的原因和这些代码都没有一毛钱的关系，是因为tws的python的api是从java转过来的，如果size的小数位很长，数据就无法传递，所以事先要round一下小数位（摊手&lt;/li&gt;
&lt;li&gt;前几天遇到的另外一个bug是ibapi只接受int格式的size指令，如果是float就不执行（继续摊手&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;一段蜜汁代码&#34;&gt;一段蜜汁代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def stop_loss(self, side, size, stoplossprice):
    logger.warning(&#39;[{}] stop loss, side = {}, size = {}, price = {}&#39;.format(len(self), side, size, stoplossprice))

    size = int(size)

    if not self.stop1:

        if side == -1:
            self.stop1 = self.strategy.sell(
                data = self.data,
                size = size,
                price = stoplossprice,
                exectype = bt.Order.Stop,
            )
            self.stoplossorder = self.stop1
        elif side == 1:
            self.stop1 = self.strategy.buy(
                data = self.data,
                size = size,
                price = stoplossprice,
                exectype = bt.Order.Stop,
            )
            self.stoplossorder = self.stop1

    elif self.stop1 and not self.stop2:
        if side == -1:
            self.stop2 = self.strategy.sell(
                data = self.data,
                size = size,
                price = stoplossprice,
                exectype = bt.Order.Stop,
            )

            self.stoplossorder = self.stop2
        elif side == 1:
            self.stop2 = self.strategy.buy(
                data = self.data,
                size = size,
                price = stoplossprice,
                exectype = bt.Order.Stop,
            )

            self.stoplossorder = self.stop2

    elif self.stop1 and self.stop2 and not self.stop3:

        if side == -1:
            self.stop3 = self.strategy.sell(
                data = self.data,
                size = size,
                price = stoplossprice,
                exectype = bt.Order.Stop,
            )

            self.stoplossorder = self.stop3
        elif side == 1:
            self.stop3 = self.strategy.buy(
                data = self.data,
                size = size,
                price = stoplossprice,
                exectype = bt.Order.Stop,
            )

            self.stoplossorder = self.stop3


    elif self.stop1 and self.stop2 and self.stop3 and not self.stop4:

        if side == -1:
            self.stop4 = self.strategy.sell(
                data = self.data,
                size = size,
                price = stoplossprice,
                exectype = bt.Order.Stop,
            )

            self.stoplossorder = self.stop4
        elif side == 1:
            self.stop4 = self.strategy.buy(
                data = self.data,
                size = size,
                price = stoplossprice,
                exectype = bt.Order.Stop,
            )

            self.stoplossorder = self.stop4

    elif self.stop1 and self.stop2 and self.stop3 and self.stop4 and not self.stop5:
        if side == -1:
            self.stop5 = self.strategy.sell(
                data = self.data,
                size = size,
                price = stoplossprice,
                exectype = bt.Order.Stop,
            )

            self.stoplossorder = self.stop5
        elif side == 1:
            self.stop5 = self.strategy.buy(
                data = self.data,
                size = size,
                price = stoplossprice,
                exectype = bt.Order.Stop,
            )

            self.stoplossorder = self.stop5

def close_pos(self):
    logger.warning(&#39;[{}] close positions&#39;.format(len(self)))


    if self.common.side != 0:
       order = self.order_target_size(
       target = 0,
       )

    if self.stop1 and self.stop1.alive():
    	self.strategy.cancel(self.stop1)
   	if self.stop2 and self.stop2.alive():
        self.strategy.cancel(self.stop2)
    if self.stop3 and self.stop3.alive():
        self.strategy.cancel(self.stop3)
    if self.stop4 and self.stop4.alive():
        self.strategy.cancel(self.stop4)
    if self.stop5 and self.stop5.alive():
        self.strategy.cancel(self.stop5)

    self.stop1 = None
    self.stop2 = None
    self.stop3 = None
    self.stop4 = None
    self.stop5 = None
    self.order = None
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>搬瓦工VPS上搭建Wordpress站点</title>
      <link>https://jarrywangcn.github.io/post/bandwagon_wordpress/</link>
      <pubDate>Wed, 01 Mar 2017 17:10:40 +0800</pubDate>
      
      <guid>https://jarrywangcn.github.io/post/bandwagon_wordpress/</guid>
      <description>&lt;p&gt;个站直接托管在github, 就绕过了买虚拟主机或者服务器的过程，这次&lt;a href=&#34;lookcn.org&#34;&gt;路客中国&lt;/a&gt;的建站一开始为了图省力，用了亚马逊的aws，没有考虑到国内用户的访问问题。&lt;/p&gt;

&lt;p&gt;考虑到提供主要云服务的公司（amazon aws，google）都很容易被墙，所以只能买个主机。（个人偏好没有考虑国内的服务商，好像主机公园的风评还不错）。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;一-购买虚拟主机&#34;&gt;一、购买虚拟主机&lt;/h2&gt;

&lt;p&gt;国内访问亚马逊IP Ping测试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PING x.x.x.x (x.x.x.x): 56 data bytes
Request timeout for icmp_seq 0
Request timeout for icmp_seq 1
Request timeout for icmp_seq 2
Request timeout for icmp_seq 3
Request timeout for icmp_seq 4
Request timeout for icmp_seq 5
--- x.x.x.x ping statistics ---
7 packets transmitted, 0 packets received, 100.0% packet loss
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;丢包到崩溃&amp;hellip;
​&lt;br /&gt;
主机提供商的可选项真是多到爆炸&amp;hellip;最后在小伙伴的帮助下，考虑了速度、性价比等，选择使用bandwagon。买了虚拟主机后，一切才刚刚开始&amp;hellip;&lt;/p&gt;

&lt;p&gt;国内访问bandwagon fermont IP Ping测试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PING x.x.x.x (x.x.x.x): 56 data bytes
64 bytes from 98.142.135.33: icmp_seq=0 ttl=52 time=295.267 ms
64 bytes from 98.142.135.33: icmp_seq=1 ttl=52 time=257.185 ms
64 bytes from 98.142.135.33: icmp_seq=2 ttl=52 time=329.819 ms
64 bytes from 98.142.135.33: icmp_seq=3 ttl=52 time=258.983 ms
64 bytes from 98.142.135.33: icmp_seq=4 ttl=52 time=269.134 ms
64 bytes from 98.142.135.33: icmp_seq=5 ttl=52 time=279.991 ms
--- x.x.x.x ping statistics ---
6 packets transmitted, 6 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 257.185/281.730/329.819/25.091 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有点慢了 昨晚测试大约在180ms左右&lt;/p&gt;

&lt;h2 id=&#34;二-安装虚拟主机控制系统&#34;&gt;二、安装虚拟主机控制系统&lt;/h2&gt;

&lt;p&gt;一般动态网站的解决方案是LAMP，Linux+Apache+Mysql/MariaDB+Perl/PHP/Python。Linux为主机的操作系统，Apache为服务器，MySQL为数据库软件，PHP为动态网站编程语言。&lt;/p&gt;

&lt;p&gt;bandwagon VPS便宜是因为它是&amp;rdquo;self-managed&amp;rdquo; VPS，意思是除了主机和一个没什么用的Kiwi Control Panel以外什么都要自己搞&amp;hellip; 而一般主机服务上（如主机公园）会提供cPanel,cPanel是一种虚拟主机控制系统（cPanel要收费）。虚拟主机控制系统是GUI，没有它你就只能用命令行（我对命令行的爱还没有那么深）。于是我使用了Webmin&amp;amp;Virtualmin作为cPanel的免费替代产品。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Virtualmin/Webmin面板是免费的基于Linux VPS/服务器可以使用的用户管理网站的应用程序。相当于WHM/Cpanel的功能，我们可以在安装后的VPS中进行站点的管理和创建。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;安装过程参考&lt;a href=&#34;http://www.itbulu.com/virtualmin-webmin-install.html&#34;&gt;Virtualmin/Webmin免费VPS主机/服务器网站管理面板安装及设置&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先要利用命令行ssh连接虚拟主机（搬瓦工里自带root shell不太好用&amp;hellip;）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh user@x.x.x.x -p 22
# user: 用户名, x.x.x.x: IP地址, -p 22: 端口
# 然后输入密码
# 登录成功后在浏览器里输入 https://x.x.x.x:10000/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行下列命令：
​&lt;br /&gt;
    wget &lt;a href=&#34;http://software.virtualmin.com/gpl/scripts/install.sh&#34;&gt;http://software.virtualmin.com/gpl/scripts/install.sh&lt;/a&gt;
    chmod +x install.sh
    ./install.sh
    # 可能会提醒确认hostname, 输入IP地址即可安装&lt;/p&gt;

&lt;p&gt;文章里有国内改良版的一键安装包，但不推荐，比如我就踩坑了，那个包安装完系统语言变成了乱码&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;三-安装wordpress插件&#34;&gt;三、安装Wordpress插件&lt;/h2&gt;

&lt;p&gt;此步骤参考&lt;a href=&#34;https://aatayyab.wordpress.com/2015/08/31/wordpress-installer-script-on-virtualmin/&#34;&gt;WordPress Installer Script on Virtualmin&lt;/a&gt; 但我没有用命令行的方法（用了发现不行&amp;hellip;）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ohvamo1vj.bkt.clouddn.com/Screen%20Shot%202017-03-01%20at%205.47.40%20PM.png&#34; alt=&#34;virtualminwordpress&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我是直接在virtualmin的system settings里点script installers，然后add script的选项里选&amp;rdquo;HTTP or FTP URL&amp;rdquo;输入 &lt;a href=&#34;https://s3.amazonaws.com/cgilligan-share/custompress.pl&#34;&gt;https://s3.amazonaws.com/cgilligan-share/custompress.pl&lt;/a&gt; (这个版本的wordpress比较旧 但之后可以很方便地更新 所以没有大碍)&lt;/p&gt;

&lt;p&gt;安装完成后要create virtual server，再install scripts&lt;/p&gt;

&lt;p&gt;有个非常重要的事是在install options的install sub-directory under public_html一定要选at top level，这样你的主域名就直接是wordpress页面，而不是你的虚拟主机。
&lt;img src=&#34;http://ohvamo1vj.bkt.clouddn.com/Screen%20Shot%202017-03-01%20at%205.50.52%20PM.png&#34; alt=&#34;installwordpress&#34; /&gt;&lt;/p&gt;

&lt;p&gt;之后在浏览器输入你的IP地址,或者在域名解析完成后输入域名（请把virtual server的domain name改成主域名），都可直接出现wordpress页面。&lt;/p&gt;

&lt;p&gt;其他：我域名服务商是godayy，域名解释用的是DSNpod，只需要更改DSNpod的IP地址就可以了。&lt;/p&gt;

&lt;h2 id=&#34;四-wordpress迁移&#34;&gt;四、Wordpress迁移&lt;/h2&gt;

&lt;p&gt;用的是官方的import, export功能，只能导入posts, pages, comments等内容，插件和主体配置不能导入&amp;hellip; 以后网站内容多了一定需要研究下整体迁移的方法。&lt;/p&gt;

&lt;p&gt;最后的最后：DSN解析是分布式的，所以有些地方解析完了，有些地方没解析完&amp;hellip;最长24小时完成，所以只能睡一觉&amp;hellip; 睡一觉还不行就只能再睡一觉&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用python下载instagram图片（中国大陆）</title>
      <link>https://jarrywangcn.github.io/post/download_from_instagram/</link>
      <pubDate>Sat, 21 Jan 2017 20:47:56 +0800</pubDate>
      
      <guid>https://jarrywangcn.github.io/post/download_from_instagram/</guid>
      <description>&lt;h1 id=&#34;0&#34;&gt;0.&lt;/h1&gt;

&lt;p&gt;本科毕业论文做的是默克尔和奥巴马instagram形象对比分析，当年半点程序背景都没有（拿chrome查看源代码找图片链接到是会的）但instagram似乎挺不支持这个行为，源代码里都找不到图片地址。所以，当初我手动截图（加排序）了两个人官方账号里的所有图片。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;所以，稍微学习了一点编程就想把这件事实现了。&lt;/p&gt;

&lt;h1 id=&#34;1-instaraider-instalooter&#34;&gt;1. instaRaider &amp;amp; instaLooter&lt;/h1&gt;

&lt;p&gt;谷歌搜索了下，发现已经有人造好了轮子&lt;a href=&#34;https://github.com/akurtovic/InstaRaider&#34;&gt;instaRaider&lt;/a&gt;，而且把怎么造轮子的过程都写清楚了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.amirkurtovic.com/blog/how-to-download-photos-from-instagram-a-hack/&#34;&gt;How to download photos from Instagram – A Hack&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个项目吸引我的地方是它不需要instagram的api，所以也不需要授权(authentication)。&lt;/p&gt;

&lt;p&gt;但这个项目已经停止维护了，instaRaider的作者在readme里推荐了另一个项目&lt;a href=&#34;https://github.com/althonos/InstaLooter&#34;&gt;instaLooter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当我看到instaLooter的readme里使用方式只有两行代码时我的内心好喜悦啊
​&lt;br /&gt;
    $ instaLooter &lt;username&gt; &lt;directory&gt; [options]
    $ instaLooter hashtag &lt;hashtag&gt; &lt;directory&gt; [options]&lt;/p&gt;

&lt;p&gt;然后就报错了&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;requests.exceptions.ConnectionError: HTTPSConnectionPool(host=&#39;www.instagram.com&#39;, port=443): Max retries exceeded with url: /jarrywan9/ (Caused by NewConnectionError(&#39;&amp;lt;requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x10402a4d0&amp;gt;: Failed to establish a new connection: [Errno 65] No route to host&#39;,))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因是我instagram在国内被封了&amp;hellip;而我翻墙走的是shadowsocks&lt;/p&gt;

&lt;h1 id=&#34;2-利用proxychains解决shadowsocks非全局代理问题&#34;&gt;2. 利用proxychains解决shadowsocks非全局代理问题&lt;/h1&gt;

&lt;p&gt;下面开始感恩前室友小讲堂：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;代理通常分两步：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;把线路搞起来 e.g. shadowsocks或vpn&lt;/li&gt;
&lt;li&gt;让程序流量走这个线路&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;代理可分为全局代理和非全局代理。&lt;/p&gt;

&lt;p&gt;全局代理是全部程序的流量都走代理，譬如通常的vpn。&lt;/p&gt;

&lt;p&gt;而shadowsocks是非全局的，默认是连上之后本地开一个服务端口 譬如1080，然后通常把浏览器流量设置到走这个端口。ss本质是一个socks5服务，需要监听一个本地端口，这个就是ss服务跑起来以后在你机器上面的服务端口(其他程序譬如浏览器会把流量发到这个端口，由ss发到境外服务器）（我目前用的shadowsocks软件是shadowsocksx2，端口是写死了的1080）&lt;/p&gt;

&lt;p&gt;解决方案有两个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用一个全局的翻墙方案 譬如vpn 这样这个python脚本的流量默认翻墙了&lt;/li&gt;
&lt;li&gt;仍然是shadowsocks 不过设置程序流量走ss这个服务端口&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;// 考虑第二个方案的实现成本比让前室友重新设置个vpn给我低一些 所以选择了方案二）&lt;/p&gt;

&lt;p&gt;此时，要用到另外一个轮子 &lt;a href=&#34;https://github.com/haad/proxychains&#34;&gt;proxychains&lt;/a&gt;,
设置方法参照了&lt;a href=&#34;http://www.tuicool.com/articles/rUNFF3&#34;&gt;利用proxychains在终端使用socks5代理&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# proxychains安装
git clone https://github.com/rofl0r/proxychains-ng.git
cd proxychains-ng
./configure
make &amp;amp;&amp;amp; make install
cp ./src/proxychains.conf /etc/proxychians.conf
cd .. &amp;amp;&amp;amp; rm -rf proxychains-ng

# 编辑proxychains配置
# 需要学习下vim的操作，配置文件修改需要管理员权限 mac环境下前面加sudo
vim /etc/proxychains.conf

# 将socks4 127.0.0.1 9095改为
socks5  127.0.0.1 1080  //1080改为你自己的端口

# 在需要代理的命令前加上 proxychains4，如：
proxychains4 instaLooter jarrywan9 ./Downloads/jarrywan9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他需要注意的一些事情：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每个轮子都有Requirements，要确认下是否都安装了&lt;/li&gt;
&lt;li&gt;proxychains用$ brew install proxychains 也可以安装，我是brew刚好需要更新，但死也更新不了&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;4-总结&#34;&gt;4. 总结&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;学习编程时要尝试解决实际问题&lt;/li&gt;
&lt;li&gt;有轮子的时候就用轮子，避免重复劳动（虽然现在我也写不出&amp;hellip;）&lt;/li&gt;
&lt;li&gt;开源项目的readme要认真写，&lt;a href=&#34;https://github.com/althonos/InstaLooter&#34;&gt;instaLooter&lt;/a&gt;的小哥readme和代码写的都很干净&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后晒一张成果 instagram@will_yinan&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ohvamo1vj.bkt.clouddn.com/Screen%20Shot%202017-01-21%20at%209.58.43%20PM.png&#34; alt=&#34;will_yinan&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用七牛云&#43;dropzone在静态博客中插入图片</title>
      <link>https://jarrywangcn.github.io/post/upload_photos/</link>
      <pubDate>Thu, 08 Dec 2016 20:21:25 +0800</pubDate>
      
      <guid>https://jarrywangcn.github.io/post/upload_photos/</guid>
      <description>&lt;p&gt;用wordpress, medium之类的博客服务，想要在文章中插入图片，网站有自己的服务器可以上传图片。如果自己架设网站，就需要把照片上传到互联网，获取网址，才能利用markdown语法在文章中插入图片。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;可以选择例如flickr这样的网络相册（会提供照片外链网址），考虑到flickr已经被墙了，遂放弃，也不想为此重新注册一个网络相册。&lt;/p&gt;

&lt;p&gt;也可以选择例如七牛、github，把图片上传到服务器，获得外链。本来想选github后来听说官方不支持这种用法，外加看到一篇使用七牛云+dropzone拖拽上传图片自动复制外链到剪贴板的&lt;a href=&#34;http://yansu.org/2015/01/10/use-dropzone-and-qiniu-to-store-blog-images.html&#34;&gt;文章&lt;/a&gt;，就决定使用七牛云。&lt;/p&gt;

&lt;h3 id=&#34;操作步骤&#34;&gt;操作步骤&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;注册七牛云，并创建存储空间&lt;/li&gt;
&lt;li&gt;在appstore上购买dropzone 3 (12人民币)，再去官网下载沙箱版&lt;a href=&#34;https://aptonic.com&#34;&gt;dropzone3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在&lt;a href=&#34;https://aptonic.com/actions/untested&#34;&gt;untested action&lt;/a&gt;中选择qiniu插件install&lt;/li&gt;
&lt;li&gt;配置插件，操作见&lt;a href=&#34;http://yansu.org/2015/01/10/use-dropzone-and-qiniu-to-store-blog-images.html&#34;&gt;使用Dropzone和七牛优化博客图床&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;尝试拖拽上传文件，生成外链，使用⬇️(在第四步中选择了本地图片备份，在选择的目录下也出现了上传的文件)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://ohvamo1vj.bkt.clouddn.com/IMG_0919.JPG&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;压缩图片之后上传&#34;&gt;压缩图片之后上传&lt;/h2&gt;

&lt;p&gt;目前使用的是苹果的预览工具，想要在dropzone里实现&amp;hellip;&lt;/p&gt;

&lt;p&gt;苹果预览修改尺寸效果如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ohvamo1vj.bkt.clouddn.com/IMG_09190.JPG&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;update&#34;&gt;update&lt;/h3&gt;

&lt;p&gt;使用dropzone插件1024px，但感觉1024像素在博客中还是有些大，自己修改了代码调成800，缺陷是自动覆盖原文件，所以最好是先备份再压缩，但已经挺方便了，满足。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用hugo和github pages搭建个人博客</title>
      <link>https://jarrywangcn.github.io/post/buildnewblog/</link>
      <pubDate>Thu, 08 Dec 2016 17:16:37 +0800</pubDate>
      
      <guid>https://jarrywangcn.github.io/post/buildnewblog/</guid>
      <description>&lt;p&gt;之前尝试过很多次搭建个人博客，看到Wilson Lee的网站使用format做portfolio，效果很棒，但收费挺高。买过几个域名，挺久之前买过jarry.wang 到期了也没用过一次，七月买了jarrywang.de。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;花了挺大功夫，自建博客很多人推荐用wordpress，但我觉得wordpress相当麻烦，很厚重，用了个其他的（忘记叫啥）。当时托管在亚马逊aws，创建instance解析ip地址又弄了很久，但还是搞定了。就是在网址上输入xx.xx.xx，能看到网页。死在了最后一步，把解析的ip地址和域名绑定，forward只能跳转，还是会显示ip地址。弄了三天左右，最后放弃了&amp;hellip;&lt;/p&gt;

&lt;p&gt;今天下午弄了四个小时，就全部搞定了。方法是用hugo搭建网站，托管在github pages上，github会自动生成一个可访问的网站 &lt;code&gt;your_username.github.io&lt;/code&gt;，在域名管理中加入三个DNS设置，要在project中加一个文件。&lt;/p&gt;

&lt;p&gt;现在每次更新是先创建一个markdown文件，run hugo生成public文件夹，用git推送到在github托管的项目（目前用的是source tree，一款gui方式使用git的软件）。&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;p&gt;今天弄的这么顺利和这两个月学会的命令行、git、github起到了很大的作用。如果是之前只会用gui的话，可能真的要被wordpress弄死！dependency很重要！&lt;/p&gt;

&lt;p&gt;这两个月也习惯了看文档学东西，今天除了有些用户写的中文教程还看hugo的文档，碰到bug学会查stackoverflow，还去hugo的community里问了&amp;hellip; 感天动地！&lt;/p&gt;

&lt;h3 id=&#34;参考链接&#34;&gt;参考链接：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.coderzh.com/2015/08/29/hugo/&#34;&gt;使用hugo搭建个人博客站点&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/31377141/answer/103056861&#34;&gt;github怎么绑定自己的域名&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>